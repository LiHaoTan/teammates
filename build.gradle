apply plugin: "eclipse"
apply plugin: 'idea'

apply plugin: "war"
apply plugin: "appengine"

apply plugin: "checkstyle"
apply plugin: "pmd"
apply plugin: "findbugs"
apply plugin: "jacoco"

def appengineVersion = "1.9.27"
def checkstyleVersion = "6.19"
def pmdVersion = "5.5.4"
def findbugsVersion = "3.0.1"

if (System.properties['intellij'] == 'true') {
    buildDir = new File(projectDir, 'buildIdea')
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "com.google.appengine:gradle-appengine-plugin:1.9.27"
    }
}

configurations {
    staticAnalysis
    enhancer
    exclude
    testExclude
}

configurations.all {
    resolutionStrategy {
        force "com.google.appengine:appengine-api-1.0-sdk:${appengineVersion}"
    }
}

repositories {
    mavenCentral()
}

dependencies {
    staticAnalysis  "com.puppycrawl.tools:checkstyle:${checkstyleVersion}",
                    "net.sourceforge.pmd:pmd-java:${pmdVersion}",
                    "com.google.code.findbugs:findbugs:${findbugsVersion}",
                    "de.andrena.tools.macker:macker:1.0.1"

    appengineSdk    "com.google.appengine:appengine-java-sdk:${appengineVersion}"

    compile         "com.google.appengine.tools:appengine-gcs-client:0.4.4",
                    // AppEngine API, duplicate because of 1.9.27 name
                    "com.google.appengine:appengine-api-labs:${appengineVersion}",
                    "com.google.code.gson:gson:2.8.0",
                    "com.googlecode.owasp-java-html-sanitizer:owasp-java-html-sanitizer:20160924.1",
                    "com.mailjet:mailjet-client:4.0.5",
                    "com.sendgrid:sendgrid-java:2.2.2",
                    // mailgun
                    "com.sun.jersey:jersey-client:1.19.3",
                    //"com.sun.jersey:jersey-core:1.19.3", // this is a transitive dependency of client
                    "com.sun.jersey.contribs:jersey-multipart:1.19.3",
                    // Date-time classes before Java 8
                    "joda-time:joda-time:2.9.7",
                    // Implementation of JSTL specification
                    "org.apache.taglibs:taglibs-standard-impl:1.2.5",
                    // Parsing HTML
                    "org.jsoup:jsoup:1.10.2"

                    // AppEngine API
    exclude         "com.google.appengine:appengine-api-1.0-sdk:${appengineVersion}",
                    // AppEngine API, duplicate because of 1.9.27 name
                    "com.google.appengine:appengine-endpoints-deps:${appengineVersion}",
                    // AppEngine API, duplicate of 1.9.27 name
                    "com.google.appengine:appengine-endpoints:${appengineVersion}",
                    // AppEngine API
                    "com.google.appengine:appengine-jsr107cache:${appengineVersion}",
                    // duplicate because SDK already has a final
                    "com.google.appengine.orm:datanucleus-appengine:1.0.10",
                    "javax.jdo:jdo2-api:2.3-eb",
                    // Unused so should we should remove this?
                    // though the jsr107cache from google requires this though
                    // but it is not detected/specified by Google
                    "net.sf.jsr107cache:jsr107cache:1.1",
                    // unused? already declared in datanucleus-jpa
                    "org.apache.geronimo.specs:geronimo-jpa_3.0_spec:1.1.1",
                    // who uses this O.o?
                    "org.apache.geronimo.specs:geronimo-jta_1.1_spec:1.1.1",
                    // AppEngine ORM
                    "org.datanucleus:datanucleus-core:1.1.5",
                    // AppEngine ORM
                    "org.datanucleus:datanucleus-jpa:1.1.5",
                    "xerces:xercesImpl:2.11.0"

    runtime         configurations.exclude

    enhancer        "javax.jdo:jdo2-api:2.3-eb",
                    "joda-time:joda-time:2.9.7",
                    // specified in exclude already
                    "com.google.appengine.orm:datanucleus-appengine:1.0.10",
                    // specified in exclude already
                    "org.datanucleus:datanucleus-core:1.1.5",
                    // specified in exclude already
                    "org.datanucleus:datanucleus-jpa:1.1.5",
                    // specified in exclude already
                    "com.google.appengine:appengine-api-1.0-sdk:${appengineVersion}"

    testCompile     "com.google.appengine:appengine-api-stubs:${appengineVersion}",
                    "com.google.appengine:appengine-remote-api:${appengineVersion}",
                    "com.google.appengine:appengine-testing:${appengineVersion}",
                    "httpunit:httpunit:1.7",
                    "javax.mail:mail:1.4.7",
                    "org.seleniumhq.selenium:selenium-java:2.53.1",
                    "org.testng:testng:6.9.4",
                    "org.kohsuke:wordnet-random-name:1.3"

    testExclude     "com.google.appengine:appengine-tools-sdk:${appengineVersion}"

    testRuntime     configurations.testExclude

}

sourceSets {
    main {
        java {
            srcDir "src/main/java"
            include "**/*.java"
        }
        resources {
            srcDir "src/main/resources"
            exclude "**/*.java"
        }
    }
    test {
        java {
            srcDir "src/test/java"
            srcDir "src/client/java"
            include "**/*.java"
        }
        resources {
            srcDir "src/test/resources"
            exclude "**/*.java"
        }
    }
}

sourceSets.remove(sourceSets.functionalTest) // TODO still some remnants, cleared from IDEA plugin above
sourceSets.remove(sourceSets.endpointsSrc)

// SETUP TASKS

import org.gradle.plugins.ide.eclipse.model.SourceFolder

eclipse {
    project {
        natures "org.eclipse.jdt.core.javanature", "com.google.appengine.eclipse.core.gaeNature", "org.eclipse.wst.jsdt.core.jsNature"
        buildCommand "org.eclipse.jdt.core.javabuilder"
        buildCommand "com.google.gdt.eclipse.core.webAppProjectValidator"
        buildCommand "com.google.appengine.eclipse.core.enhancerbuilder"
        buildCommand "com.google.appengine.eclipse.core.projectValidator"
        buildCommand "org.eclipse.wst.validation.validationbuilder"
    }
    classpath {
        containers "com.google.appengine.eclipse.core.GAE_CONTAINER/appengine-java-sdk-1.9.27"
        defaultOutputDir = file("src/main/webapp/WEB-INF/classes")
        sourceSets = [sourceSets.main, sourceSets.test]
        minusConfigurations = [configurations.exclude, configurations.testExclude]
        file {
            whenMerged { cp ->
                cp.entries.findAll {
                    it instanceof SourceFolder && !it.path.startsWith("src/main/")
                }*.output = "target/test-classes"

                // Method to put mail.jar on top of the classpath
                // This is necessary because placing it in its default place causes unintended name clash
                def nonMailEntries = cp.entries.findAll{ entry ->
                    !entry.path.contains("mail-1.4.7")
                }
                cp.entries.removeAll(nonMailEntries)
                cp.entries.addAll(nonMailEntries)
            }
        }
    }
}

idea {
    module {
        // TODO description Remove the sources from appengine plugin
        testSourceDirs -= file('src/functionalTest/java')
        testSourceDirs -= file('src/functionalTest/resources')
        iml {
            println "HEY I'm here"
            //if you like to keep *.iml in a secret folder
            //generateTo = file('secret-modules-folder')

            //if you want to mess with the resulting XML in whatever way you fancy
            withXml {
                println "XML WHAT'S UP"
                //println it.asString()
                //def node = it.asNode()
                node.appendNode('ihateGradle', 'true')
                //node.appendNode('butAlso', 'I find increasing pleasure tinkering with output *.iml contents. Yeah!!!')
            }

            //closure executed after *.iml content is loaded from existing file
            //but before gradle build information is merged
            beforeMerged { module ->
                //if you want skip merging exclude dirs
                //module.excludeFolders.clear()
                //println module.contentRoot.canonicalPath + "WHY"
            }

            //closure executed after *.iml content is loaded from existing file
            //and after gradle build information is merged
            whenMerged { module ->
                println "Hi"
                //you can tinker with Module
            }
        }
        //name = 'some-better-name'
        //outputDir = file("$buildDir/classes/mainlol/")
        //testOutputDir = file("$buildDir/classes/testlolROFL/")
    }
}

eclipseProject {
    onlyIf {
        !(new File(".project")).exists()
    }
}

eclipseClasspath {
    onlyIf {
        !(new File(".classpath")).exists()
    }
}

task createConfigs {
    description "Sets up the project by obtaining necessary files and configurations points."
    group "Setup"
    def templatesToCopy = [
        "gradle.template.properties",
        "src/main/resources/build.template.properties",
        "src/test/resources/test.template.properties",
        "src/main/webapp/WEB-INF/appengine-web.template.xml"
    ]
    templatesToCopy.findAll {
        !(new File(it.replace(".template", ""))).exists()
    }.each {
        filename -> copy {
            from filename
            into filename.startsWith("src/") ? new File(filename).getParent() : "${projectDir}"
            rename '(.*).template(.*)', '$1$2'
        }
    }
}

task createEclipseLaunches << {
    def templatesToCopy = [
        ".templates/eclipseLaunches/All tests.launch.xml",
        ".templates/eclipseLaunches/All tests (GodMode).launch.xml",
        ".templates/eclipseLaunches/CI tests.launch.xml",
        ".templates/eclipseLaunches/CI tests (GodMode).launch.xml",
        ".templates/eclipseLaunches/Failed tests.launch.xml",
        ".templates/eclipseLaunches/Failed tests (GodMode).launch.xml",
        ".templates/eclipseLaunches/Local tests.launch.xml",
        ".templates/eclipseLaunches/Local tests (GodMode).launch.xml"
    ]
    templatesToCopy.findAll {
        !(new File(it.replace(".templates/eclipseLaunches", ".launches").replace(".xml", ""))).exists()
    }.each {
        filename -> copy {
            from filename
            into ".launches"
            rename '(.*).xml', '$1'
        }
        filename = filename.replace(".templates/eclipseLaunches", ".launches").replace(".xml", "")
        def fileContents = new File(filename).getText("UTF-8")
        def projectName = "${projectDir}".replaceAll(/.*(\/|\\)/, "")
        new File(filename).text = new File(filename).getText("UTF-8").replaceAll(/\$\{project\.name\}/, projectName)
    }
}

task createIntellijRunConfigs << {
    def templatesToCopy = [
        ".templates/intellijRunConfigs/All_Tests__Godmode_.xml",
        ".templates/intellijRunConfigs/All_Tests.xml",
        ".templates/intellijRunConfigs/CI_Tests__Godmode_.xml",
        ".templates/intellijRunConfigs/CI_Tests.xml",
        ".templates/intellijRunConfigs/Failed_Tests__Godmode_.xml",
        ".templates/intellijRunConfigs/Failed_Tests.xml",
        ".templates/intellijRunConfigs/Local_Tests__Godmode_.xml",
        ".templates/intellijRunConfigs/Local_Tests.xml"
    ]
    templatesToCopy.findAll {
        !(new File(it.replace(".templates/intellijRunConfigs", ".idea/runConfigurations"))).exists()
    }.each {
        filename -> copy {
            from filename
            into ".idea/runConfigurations"
        }
    }
}

task copyDepsToWebInfLib(type: Copy) {
    from configurations.runtime
    into "src/main/webapp/WEB-INF/lib/"
    rename("datanucleus-appengine-1.0.10.jar", "datanucleus-appengine-1.0.10.final.jar")
    rename("appengine-endpoints-deps-1.9.27.jar", "appengine-endpoints-deps.jar")
    rename("appengine-endpoints-1.9.27.jar", "appengine-endpoints.jar")
    rename("appengine-api-labs-1.9.27.jar", "appengine-api-labs.jar")
}

task resetEclipseDeps {
    description "Updates the project's dependencies to be used by Eclipse configurations"
    group "Setup"
    doFirst {
        delete  ".classpath",
                "src/main/webapp/WEB-INF/lib"
    }
    finalizedBy eclipseClasspath, copyDepsToWebInfLib
}

task printUserHomeDir << {
    println "Your Gradle user directory is: ${gradle.gradleUserHomeDir}"
}

task setupEclipse {
    description "Sets up the Eclipse-specific configurations for the project."
    group "Setup"
    dependsOn eclipseProject, createEclipseLaunches, resetEclipseDeps
}

task setupIntellij {
    description "Sets up the IntelliJ-specific configurations for the project."
    group "Setup"
    dependsOn createIntellijRunConfigs
}

// RUN SERVER TASKS

compileJava.options.encoding = "UTF-8"
compileTestJava.options.encoding = "UTF-8"

appengine {
    httpPort = 8888
    downloadSdk = true
    jvmFlags = ["-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8"]
    appcfg {
        oauth2 = true
    }
}

appengineRun {
    if (project.hasProperty("disable_daemon")) {
        daemon = false
    } else {
        daemon = true
    }
}

task removeDuplicateLibs(type: Delete) {
    delete  "${buildDir}/exploded-app/WEB-INF/lib/datanucleus-appengine-1.0.10.final.jar",
            "${buildDir}/exploded-app/WEB-INF/lib/appengine-endpoints-deps.jar",
            "${buildDir}/exploded-app/WEB-INF/lib/appengine-endpoints.jar",
            "${buildDir}/exploded-app/WEB-INF/lib/appengine-api-labs.jar"
}

appengineExplodeApp.finalizedBy removeDuplicateLibs

task moveExplodedDir {
    //file("${buildDir}/exploded-app").renameTo(file("${buildDir}/exploded-app2"))
}
//appengineExplodeApp.finalizedBy moveExplodedDir


task enhancerRun << {
    def path = System.getProperty("java.class.path") + ":" + project.gradle.gradleUserHomeDir + "/appengine-sdk/appengine-java-sdk-${appengineVersion}/lib/appengine-tools-api.jar"
    ant.taskdef(name: "enhance", classpath: path, classname: "com.google.appengine.tools.enhancer.EnhancerTask")
    ant.enhance(failonerror: true, verbose: true) {
        classpath {
            pathelement(path: path)
            pathelement(path: sourceSets.main.output.classesDir.canonicalPath)
            pathelement(path: project.configurations.enhancer.asPath)
        }
        fileset(dir: sourceSets.main.output.classesDir.canonicalPath, includes: "teammates/storage/entity/*.class")
        // TODO be removed because we are not actually using JPA
        arg(value: "-enhancerVersion"); arg(value: "v1")
        arg(value: "-api"); arg(value: "JPA")
    }
}

enhancerRun.dependsOn appengineDownloadSdk
enhancerRun.dependsOn project.classes
enhancerRun.shouldRunAfter project.testClasses
war.dependsOn enhancerRun

// STATIC ANALYSIS TASKS

def isWindows = System.getProperty("os.name").toLowerCase().contains("windows")

checkstyle {
    toolVersion = checkstyleVersion
    configFile = file("static-analysis/teammates-checkstyle.xml")
}

pmd {
    toolVersion = pmdVersion
    consoleOutput = true
    ruleSetFiles = files("static-analysis/teammates-pmd.xml", "static-analysis/teammates-pmdMain.xml")
    ruleSets = []
}

findbugs {
    toolVersion = findbugsVersion
    visitors = [
        "FindDeadLocalStores"
    ]
}

tasks.withType(FindBugs) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

task downloadStaticAnalysisTools {
    description "Downloads all static analysis tools."
    group "Static analysis"
    doFirst {
        configurations.staticAnalysis.resolve()
    }
}

task lintMain {
    dependsOn checkstyleMain, pmdMain, findbugsMain
}

task lintTest {
    dependsOn checkstyleTest, pmdTest, findbugsTest
}

task macker << {
    logging.setLevel(LogLevel.INFO)
    ant.taskdef(name: "macker", classpath: configurations.staticAnalysis.asPath, classname: "de.andrena.tools.macker.ant.MackerAntTask")
    ant.macker(failonerror: true, verbose: false) {
        rules(dir: "${projectDir}/static-analysis", includes: "teammates-macker.xml")
        classes(dir: "${buildDir}/classes") {
            include(name: "**/*.class")
        }
    }
}

macker.dependsOn testClasses
macker.shouldRunAfter lintMain, lintTest

task lint {
    description "Runs the entire static analysis tasks for back-end."
    group "Static analysis"
    dependsOn lintMain, lintTest, macker
}

// TEST TASKS

def numOfTestRetries = 3
def isTravis = System.getenv("TRAVIS") != null
def isAppVeyor = System.getenv("APPVEYOR") != null
def failedXmlPath = "test-output/testng-failed.xml"
def failedXmlUrl = "https://gist.githubusercontent.com/anonymous/gist_id/raw/"

// Displays full exception; to be run after the test fails after the last retry
// For HTML tests, the exception is displayed in diff form instead of the extremely verbose full exception message
def afterTestClosure = { descriptor, result ->
    if (result.resultType == TestResult.ResultType.FAILURE && result.exception != null && result.exception.getMessage() != null) {
        println ""

        def msg = result.exception.getMessage()
        def shouldDisplayAsDiff = msg.indexOf("<<expected>") != -1
        if (shouldDisplayAsDiff) {
            def expectedFileName = "expected-${descriptor.getClassName()}"
            def actualFileName = "actual-${descriptor.getClassName()}"
            file("${expectedFileName}").text = msg[(msg.indexOf("<<expected>") + 11)..(msg.indexOf("</expected>>") - 1)]
            file("${actualFileName}").text = msg[(msg.indexOf("<<actual>") + 9)..(msg.indexOf("</actual>>") - 1)]
            def diffCommand = isWindows ? "FC" : "diff"
            def process = "${diffCommand} ${expectedFileName} ${actualFileName}".execute()
            println process.getText()
            process.waitFor()
            if (!isAppVeyor && !isTravis) { // CI does not allow deleting files
                def deleteCommand = isWindows ? "del" : "rm"
                "${deleteCommand} ${expectedFileName}".execute()
                "${deleteCommand} ${actualFileName}".execute()
            }
        } else {
            println "${result.exception.getClass().getName()}: ${result.exception.getMessage()}"
        }

        for (StackTraceElement ste : result.exception.getStackTrace()) {
            if (ste.getClassName().contains("NativeMethodAccessorImpl")) {
                // Everything after this line is the internal workings of TestNG, not important for us
                println "\t..."
                break
            }
            println "\tat ${ste.getClassName()}.${ste.getMethodName()}(${ste.getFileName()}:${ste.getLineNumber()})"
        }
    }
}

def checkConfigFailureClosure = { descriptor, result ->
    if (result.exception instanceof org.gradle.internal.serialize.PlaceholderException
            && result.exception.toString().startsWith("org.gradle.api.internal.tasks.testing.TestSuiteExecutionException")) {
        throw new GradleException('Detected TestNG configuration failure - check src/test/testng-ci.xml')
    }
}

test {
    useTestNG()
    options.useDefaultListeners = true
    ignoreFailures false
    maxHeapSize = "1g"
    reports.html.enabled = false
    reports.junitXml.enabled = false
    if (project.hasProperty("godmode")) {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8", "-Dgodmode=true"
    } else {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8"
    }
    afterTest afterTestClosure
    testLogging {
        events "passed"
    }
    dependsOn enhancerRun
}

task localTests(type: Test) {
    useTestNG()
    options.suites "src/test/testng-local.xml"
    options.outputDirectory = file("build/reports/test-local")
    options.useDefaultListeners = true
    ignoreFailures false
    maxHeapSize = "1g"
    reports.html.enabled = false
    reports.junitXml.enabled = false
    if (project.hasProperty("godmode")) {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8", "-Dgodmode=true"
    } else {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8"
    }
    afterTest afterTestClosure
    testLogging {
        events "passed"
    }
    dependsOn enhancerRun
}

task failedTests(type: Test) {
    useTestNG()
    options.suites "test-output/testng-failed.xml"
    options.outputDirectory = file("build/reports/test-failed")
    options.useDefaultListeners = true
    ignoreFailures false
    maxHeapSize = "1g"
    reports.html.enabled = false
    reports.junitXml.enabled = false
    if (project.hasProperty("godmode")) {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8", "-Dgodmode=true"
    } else {
        jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8"
    }
    afterTest afterTestClosure
    testLogging {
        events "passed"
    }
    dependsOn enhancerRun
}

task ciTests {
    description "Runs the full test suite and retries failed test up to ${numOfTestRetries} times."
    group "Test"
}

(1..numOfTestRetries + 1).each { id ->
    def isFirstTry = id == 1
    def isLastRetry = id == numOfTestRetries + 1
    task "testTry${id}"(type: Test) {
        useTestNG()
        options.suites isFirstTry ? "src/test/testng-ci.xml" : "build/reports/test-try-${id - 1}/testng-failed.xml"
        options.outputDirectory = file("build/reports/test-try-${id}")
        options.useDefaultListeners = true
        ignoreFailures = !isLastRetry
        maxHeapSize = "1g"
        reports.html.enabled = false
        reports.junitXml.enabled = false
        if (isTravis) {
            jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8", "-Djava.io.tmpdir=" + System.getenv("TRAVIS_BUILD_DIR")
        } else if (project.hasProperty("godmode")) {
            jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8", "-Dgodmode=true"
        } else {
            jvmArgs "-Duser.timezone=UTC", "-Xss2m", "-Dfile.encoding=UTF-8"
        }
        testLogging {
            events "passed"
        }
        if (isLastRetry) {
            afterTest afterTestClosure
        } else if (isFirstTry) {
            afterSuite checkConfigFailureClosure
        }
        finalizedBy "killFirefox${id}"
        dependsOn enhancerRun
        onlyIf {
            isFirstTry || file("build/reports/test-try-${id - 1}/testng-failed.xml").exists()
        }
    }
    ciTests.dependsOn "testTry${id}"

    task "killFirefox${id}"(type: Exec) {
        doFirst {
            if (isWindows) {
                commandLine "taskkill", "/f", "/im", "firefox.exe"
            } else {
                commandLine "pkill", "firefox"
            }
            // Silence output for this task
            standardOutput = new ByteArrayOutputStream()
            errorOutput = standardOutput
        }
        ignoreExitValue = true
        outputs.upToDateWhen { false }
    }
}

task generateFailedCmd(type: Exec) {
    def os = new ByteArrayOutputStream()
    doFirst {
        commandLine "gist", "-p", "build/reports/test-try-${numOfTestRetries + 1}/testng-failed.xml"
        standardOutput = os
    }
    doLast {
        def gistUrl = os.toString()
        def gistHash = gistUrl.substring(gistUrl.lastIndexOf("/") + 1).replaceAll("\\s", "")
        println "Run failed tests locally by downloading the XML file containing the failed tests using the command:"
        println "Windows: gradlew.bat -Pgist=${gistHash} downloadFailedXml"
        println "Linux/OS X: ./gradlew -Pgist=${gistHash} downloadFailedXml"
        println "followed by running \"Failed tests\" in Eclipse/IntelliJ or using the following command:"
        println "Windows: gradlew.bat failedTests"
        println "Linux/OS X: ./gradlew failedTests"
    }
}

task cleanTestOutputDir << {
    def testOutputDir = new File("test-output")
    testOutputDir.deleteDir()
}

task downloadFailedXml {
    description "Downloads testng-failed.xml from a failed run in Travis/AppVeyor."
    group "Test"
    onlyIf {
        project.hasProperty("gist")
    }
    doFirst {
        def failedXml = new File(failedXmlPath)
        failedXml.getParentFile().mkdirs()
        def downloadUrl = failedXmlUrl.replace(/gist_id/, project.getProperty("gist"))
        new URL(downloadUrl).withInputStream{i -> failedXml.withOutputStream{ it << i }}
    }
    doLast {
        println "The XML file containing the failed tests has been downloaded successfully."
        println "You can now run the failed tests locally."
    }
    dependsOn cleanTestOutputDir
}

// COVERAGE TASKS

jacoco {
    toolVersion = "0.7.8"
}

task jacocoMerge(type: JacocoMerge) {
    destinationFile = file("${buildDir}/jacocoMerge/jacocoMerge.exec")
    executionData fileTree("${buildDir}/jacoco").files
}

task jacocoReport(type: JacocoReport) {
    description "Runs coverage session from available test run data."
    group "Test"
    sourceDirectories = files(sourceSets.main.java.srcDirs, sourceSets.test.java.srcDirs)
    classDirectories = files(sourceSets.main.output, sourceSets.test.output)
    executionData jacocoMerge.destinationFile
    reports {
        xml.enabled true
        html.enabled true
    }
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ["**/*.jar", "teammates/client/**/*", "**/*Filter.class", "**/*Servlet.class"])
        })
    }
    dependsOn jacocoMerge
}

// NEW TESTING TASKS

task setupSourceSetTask {
//    sourceSets.test.each {test ->
//        test
//    }
    //sourceSets.remove(sourceSets.outputs)
    println "Source Sets"
    sourceSets.each {container ->
        println container.name + "YO"
    }

    sourceSets.each { container ->
        container.each { path ->
            /*path.allSource.each { source ->
                println source.canonicalPath + "Hey"
            }*/
            path.allSource.getSrcDirs().each { dirs ->
                println dirs.canonicalPath + "Hey"
            }
        }
    }
    println "End source sets"
    println "Build Dir: " + "${buildDir}"

    println "War Dir: " + war.destinationDir.canonicalPath
}

task removeUnused {
    //war.destinationDir = file("$buildDir/lmao/")
    //sourceSets.remove(sourceSets.functionalTest) // TODO still some remnants, cleared from IDEA plugin above
    //sourceSets.remove(sourceSets.endpointsSrc)
    //sourceSets.remove(sourceSets.outputs)
    //dependencies.
}

def intellijSetupGroup = 'IntelliJ Setup'

task copyRootModuleFileAsTemp(type: Copy) {
    description 'Copies the root module file as a temp file'
    group intellijSetupGroup

    from('.idea/modules/teammates.iml') {
        rename {
            return 'teammates_temp.iml'
        }
    }
    into '.idea/modules'
}

task removeRootModuleFile(type: Delete) {
    description 'Removes the root module file'
    group intellijSetupGroup

    delete '.idea/modules/teammates.iml'
}

task restoreRootModuleTempFileAsOriginal(type: Copy) {
    description 'Restores the temp file as the root module file'
    group intellijSetupGroup

    from('.idea/modules/teammates_temp.iml') {
        rename {
            return 'teammates.iml'
        }
    }
    into '.idea/modules'
}

task removeRootModuleTempFile(type: Delete) {
    description 'Removes the temp file for the root module'
    group intellijSetupGroup

    delete '.idea/modules/teammates_temp.iml'
}

import groovy.xml.StreamingMarkupBuilder

/*
 Change the root XML output folders generated by IntelliJ to reflect the same folder as the main and test module.
 The root XML generated by IntelliJ gradle integration sets the compiler output path to default, which is usually the out folder.
 This should not be a problem usually since the main and test module have specified the resources folder to be built to $buildDir.
 However, for some reason IntelliJ also copies the resources folder to the project compiler output path ($OutputPath$) causing an exception
 'Duplicate PMF name "transactions-optional" found in...' for the duplicate jdoconfig.xml found in $buildDir and $OutputPath$
*/
task changeIntelliJRootModuleOutputPathsToMatchOtherModules {
    description 'Change the root module to have the same build output path as the main and test module'
    group intellijSetupGroup

    doLast {
        def rootModuleXmlFilePath = ".idea/modules/teammates.iml"
        def rootModuleXml = new XmlParser().parse(rootModuleXmlFilePath)

        def moduleMainXml = new XmlParser().parse(".idea/modules/teammates_main.iml")
        def moduleMainRootComponent = moduleMainXml.breadthFirst().find { it.@name == 'NewModuleRootManager' }
        def outputUrl = moduleMainRootComponent.output.@url[0]

        def moduleTestXml = new XmlParser().parse(".idea/modules/teammates_test.iml")
        def moduleTestRootComponent = moduleTestXml.'*'.find { it.@name == 'NewModuleRootManager' }
        def outputTestUrl = moduleTestRootComponent['output-test'].@url[0]

        def moduleRootComponentNode = rootModuleXml.'*'.find { it.@name == 'NewModuleRootManager' }

        /*
         Add/Change the output paths and then add conflicting lines with IntelliJ generated iml so that IntelliJ's cache
         will use the new file outputted instead of from its cache. This has been tested several times but not extensively
         and is based on guesswork so it is unsafe for use except as a hack or until further investigation is complete
        */
        if (moduleRootComponentNode.attribute('inherit-compiler-output')) {
            moduleRootComponentNode.attributes().remove('inherit-compiler-output')
            // add an attribute to make the same line conflict with IntelliJ's cache
            moduleRootComponentNode.attributes().put('make-diff-conflict', 'conflict')

            def nodes = moduleRootComponentNode.children()
            nodes.add(0, new Node(null, 'output', [url: outputUrl]))
            nodes.add(1, new Node(null, 'output-test', [url: outputTestUrl]))
        } else {
            // set the attribute to a different value to continously make the cache conflict
            if (moduleRootComponentNode.'@make-diff-conflict' == 'conflict') {
                moduleRootComponentNode.'@make-diff-conflict' = 'other-conflict0'
            } else {
                moduleRootComponentNode.'@make-diff-conflict' = 'other-conflict' +
                        (moduleRootComponentNode.'@make-diff-conflict'.replace('other-conflict', '').toInteger() + 1)
            }

            moduleRootComponentNode['output'][0].@url = outputUrl
            moduleRootComponentNode['output-test'][0].@url = outputTestUrl
        }

        new File(rootModuleXmlFilePath).withWriter('UTF-8') { out ->
            out << new StreamingMarkupBuilder().bind { mkp.xmlDeclaration() }
            new XmlNodePrinter(new PrintWriter(out)).print(rootModuleXml)
        }
    }
}

// copyRootModuleFileAsTemp, removeModuleRootFile, copyRootModuleTempFileAsOriginal and removeRootModuleTempFile
// copies the root module file, delete it and copied back again.
// This attempts to force IntelliJ to use the new root module file instead of using it from its cache.
// Not sure if this actually has any effect though so it is to be investigated if this solution is to be used.
removeRootModuleTempFile.dependsOn restoreRootModuleTempFileAsOriginal
restoreRootModuleTempFileAsOriginal.dependsOn removeRootModuleFile
removeRootModuleFile.dependsOn copyRootModuleFileAsTemp
copyRootModuleFileAsTemp.dependsOn changeIntelliJRootModuleOutputPathsToMatchOtherModules

task resetIntelliJRootModuleOutputPath {
    description 'Reset IntelliJ root module to have the same build output path as other modules'
    group intellijSetupGroup

    dependsOn removeRootModuleTempFile
}

task changeExplodedWarDirectoryToMatchAppEnginePlugin {
    description 'Change the exploded war directory to build to the same folder as the appengine plugin'
    group intellijSetupGroup

    doLast {
        def explodedWarXmlFilePath = '.idea/artifacts/Gradle___teammates_war__exploded_.xml'
        def explodedWarXml = new XmlParser().parse(explodedWarXmlFilePath)
        def explodedWarArtifactNode = explodedWarXml.'*'.find { it.@type == 'exploded-war' }
        explodedWarArtifactNode['output-path'][0].value = '$PROJECT_DIR$/' + buildDir.name + '/exploded-app'

        new File(explodedWarXmlFilePath).withWriter('UTF-8') { out ->
            def nodePrinter = new XmlNodePrinter(new PrintWriter(out))
            nodePrinter.preserveWhitespace = true
            nodePrinter.print(explodedWarXml)
        }
    }
}

task setIntelliJAppEngineFacetSettings {
    def moduleMainXml = new XmlParser().parse('.idea/modules/teammates_main.iml')
    def moduleMainFacetComponent = moduleMainXml.'*'.find {it.@name == 'FacetManager'}
}

